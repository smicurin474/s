# -*- coding: utf-8 -*-
"""auto labeling DINO - valve

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DPN7U-5Orq6e2vQxK0Z5hsMkrt-AEOBK
"""

import torch
from PIL import Image
import numpy as np
from transformers import AutoProcessor, AutoModelForZeroShotObjectDetection
import os
from tqdm import tqdm
import hashlib
import pandas as pd

device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"Using device: {device}")

print("Загрузка модели Grounding DINO...")
model_id = "IDEA-Research/grounding-dino-base"
processor = AutoProcessor.from_pretrained(model_id)
model = AutoModelForZeroShotObjectDetection.from_pretrained(model_id).to(device)

def calc_hash256(filepath):
    sha256_hash = hashlib.sha256()
    with open(filepath, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def convert_to_yolo_format(box, image_width, image_height):
    """Конвертирует bbox в формат YOLO (x_center, y_center, width, height)"""
    x_min, y_min, x_max, y_max = box

    # Абсолютные координаты в относительные (0-1)
    x_center = (x_min + x_max) / 2 / image_width
    y_center = (y_min + y_max) / 2 / image_height
    width = (x_max - x_min) / image_width
    height = (y_max - y_min) / image_height

    return [x_center, y_center, width, height]

def process_image(image_path, text_prompt="tube.", box_threshold=0.25, text_threshold=0.25):
    image_pil = Image.open(image_path).convert("RGB")
    image_width, image_height = image_pil.size

    inputs = processor(images=image_pil, text=text_prompt, return_tensors="pt").to(device)

    with torch.no_grad():
        outputs = model(**inputs)

    results = processor.post_process_grounded_object_detection(
        outputs,
        inputs.input_ids,
        box_threshold,
        text_threshold,
        target_sizes=[(image_height, image_width)]
    )

    yolo_bboxes = []

    if len(results[0]['boxes']) > 0:
        max_score_idx = torch.argmax(results[0]['scores'])
        box = results[0]['boxes'][max_score_idx]

        # Конвертируем в YOLO формат
        yolo_bbox = convert_to_yolo_format(box.tolist(), image_width, image_height)
        yolo_bboxes = yolo_bbox

    return len(results[0]['boxes']) > 0, yolo_bboxes

base_dir = '/content/drive/MyDrive/ML отдел/LM ОКК/Удлинитель'

excluded_dirs = ['Контр. выборка', 'Виды удлинителей.pdf']

# Создаем DataFrame для хранения результатов
results_data = []

for dir_name in os.listdir(base_dir):
    if dir_name not in excluded_dirs and os.path.isdir(os.path.join(base_dir, dir_name)):
        input_dir = os.path.join(base_dir, dir_name)

        image_files = [f for f in os.listdir(input_dir) if os.path.isfile(os.path.join(input_dir, f))]

        for image_file in tqdm(image_files, desc=f"Обработка {dir_name}"):
            image_path = os.path.join(input_dir, image_file)

            # Вычисляем хэш исходного изображения
            image_hash = calc_hash256(image_path)

            # Обрабатываем изображение
            detected, yolo_bbox = process_image(image_path)

            # Сохраняем результаты
            results_data.append({
                'image_hash': image_hash,
                'yolo_bbox': yolo_bbox if detected else [],
                'original_filename': image_file,
                'source_directory': dir_name
            })


        print(f"Обработка {dir_name} завершена.")

# Сохраняем результаты в CSV
df = pd.DataFrame(results_data)
csv_path = '/content/detection_results.csv'
df.to_csv(csv_path, index=False, encoding='utf-8')

print(f"Обработка завершена. CSV файл с результатами сохранен в {csv_path}")
print(f"Всего обработано изображений: {len(results_data)}")
print(f"Обнаружено объектов: {len([x for x in df['yolo_bbox'] if x])}")
print("\nПример данных:")
df.head()

df = pd.read_csv('/content/detection_results.csv')

unique_hash_count = df['image_hash'].nunique()
print(f"Количество уникальных хэшей: {unique_hash_count}")

unique_hash_df = df.drop_duplicates(subset=['image_hash'])
unique_hash_df

unique_hash_df.to_csv("detection_results-unique_hashes.csv", index=False, encoding="utf-8")